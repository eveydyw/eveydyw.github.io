<!doctype html><html lang=en class=no-js><head><script src=/js/critical.bundle.min.85a7f5f23dc031d38877ecdb71b00d49e8a62c54f1ba98e75a734706ea09f30a.js integrity="sha256-haf18j3AMdOId+zbcbANSeimLFTxupjnWnNHBuoJ8wo=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.143.1"><meta name=theme content="Hinode 0.29.3"><link rel=stylesheet href="/css/main.min.2035ba2641dd892fae7cbd28eb9f8ed3c3c8330a06d3f53264b92e4aa28df477.css" integrity="sha256-IDW6JkHdiS+ufL0o65+O08PIMwoG0/UyZLkuSqKN9Hc=" crossorigin=anonymous><link rel=preload href=/fonts/inter-v12-latin-regular.woff2 as=font type=font/woff2 crossorigin><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>EV's Blog - LSH</title>
<meta name=description content="LSH (Locality-Sensitive Hashing, 局部敏感哈希) 算法"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="LSH"><meta property="og:description" content="LSH (Locality-Sensitive Hashing, 局部敏感哈希) 算法"><meta property="og:url" content="https://eveydyw.github.io/blogs/lsh/"><meta property="og:site_name" content="EV's Blog"><meta property="article:published_time" content="2024-06-17T23:04:04+08:00"><meta property="article:modified_time" content="2024-06-17T23:04:04+08:00"><meta property="og:image" content="https://eveydyw.github.io/img/logo1280x640.png"><meta property="og:image:alt" content="LSH"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="LSH"><meta name=twitter:description content="LSH (Locality-Sensitive Hashing, 局部敏感哈希) 算法"><meta name=twitter:image content="https://eveydyw.github.io/img/logo1280x640.png"><meta name=twitter:image:alt content="LSH"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://eveydyw.github.io/#/schema/organization/1","name":"Hinode","url":"https://eveydyw.github.io/","sameAs":[null,"https://github.com/gethinode/hinode"],"logo":{"@type":"ImageObject","@id":"https://eveydyw.github.io/#/schema/image/1","url":"https://eveydyw.github.io/img/logo512x512.png","width":512,"height":512,"caption":"Hinode"},"image":{"@id":"https://eveydyw.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://eveydyw.github.io/#/schema/website/1","url":"https://eveydyw.github.io/","name":"EV\u0027s Blog","description":"Hinode is a clean documentation and blog theme for your Hugo site based on Bootstrap 5.","publisher":{"@id":"https://eveydyw.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://eveydyw.github.io/blogs/lsh/","url":"https://eveydyw.github.io/blogs/lsh/","name":"LSH","description":"LSH (Locality-Sensitive Hashing, 局部敏感哈希) 算法","isPartOf":{"@id":"https://eveydyw.github.io/#/schema/website/1"},"about":{"@id":"https://eveydyw.github.io/#/schema/organization/1"},"datePublished":"2024-06-17T23:04:04CET","dateModified":"2024-06-17T23:04:04CET","breadcrumb":{"@id":"https://eveydyw.github.io/blogs/lsh/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://eveydyw.github.io/blogs/lsh/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://eveydyw.github.io/blogs/lsh/"]}]},{"@type":"BreadcrumbList","@id":"https://eveydyw.github.io/blogs/lsh/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://eveydyw.github.io/","url":"https://eveydyw.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://eveydyw.github.io/blogs/","url":"https://eveydyw.github.io/blogs/","name":"Blogs"}},{"@type":"ListItem","position":3,"item":{"@id":"https://eveydyw.github.io/blogs/lsh/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://eveydyw.github.io/blogs/lsh/#/schema/image/2","url":"https://eveydyw.github.io/img/logo1280x640.png","contentUrl":"https://eveydyw.github.io/img/logo1280x640.png","caption":"LSH"}]}]}</script><link rel=icon type=image/png sizes=16x16 href=/img/my_logo_hu_10729e67805acfd8.png><link rel=icon type=image/png sizes=32x32 href=/img/my_logo_hu_f267cd4735c3fb50.png><link rel=icon type=image/png sizes=48x48 href=/img/my_logo_hu_bc348718a5ba4099.png><link rel=apple-touch-icon sizes=180x180 href=/img/my_logo_hu_a8f52fe79483cdab.png><script>MathJax={loader:{load:["[tex]/html","[tex]/ams","[tex]/amscd"]},tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]],processEscapes:!0,packages:["base","ams","amscd"],tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"],renderActions:{addMenu:[0,"",""],checkLoading:[0,"",""]}},chtml:{scale:1,displayAlign:"center",displayIndent:"0em",lineWidth:"container"},svg:{fontCache:"global"}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js></script></head><body><div class="d-flex flex-column min-vh-100"><div class="d-flex flex-column"><div class="container-fluid fixed-top p-0"><nav class="navbar p-4 bg-body navbar-fixed-top navbar-expand-md"><div class="container-xxl p-0"><div class="d-flex navbar-container justify-content-center"><div class="d-flex align-items-center"><button class="navbar-toggler collapsed p-0 mx-auto invisible fw-30" type=button><svg class="svg-inline--fa fas fa-ellipsis fa-fw" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 448 512"><use href="#fas-ellipsis"/></svg></button></div><div class=mx-auto><a class=navbar-brand href=/ aria-label=Home><img src=/img/my_logo.svg alt="EV's Blog logo" height=30 width=30></a></div><div class="d-flex align-items-center"><button class="navbar-toggler main-nav-toggler collapsed p-0" type=button data-bs-toggle=collapse data-bs-target=#navbar-0-collapse aria-controls=navbar-0 aria-expanded=false aria-label="Toggle main navigation">
<span class="toggler-icon top-bar emphasis"></span>
<span class="toggler-icon middle-bar emphasis"></span>
<span class="toggler-icon bottom-bar emphasis"></span></button></div></div><div class="navbar-collapse collapse" id=navbar-0-collapse><div class="d-flex flex-fill ms-md-3 mt-4 mt-md-0"><form class="search flex-fill position-relative me-auto"><input class="search-input form-control is-search" type=search placeholder="Search this site" aria-label="Search this site" autocomplete=off name=search-input><div class="search-suggestions shadow bg-body rounded d-none" data-no-results="No results for"></div></form></div><ul class="navbar-nav ms-auto"><li class=nav-item><a class=nav-link data-nav=main data-nav-main=home href=/><span>Home</span>&nbsp;</a></li><li class=nav-item><a class=nav-link data-nav=main data-nav-main=blogs href=/Blogs/><span>Blogs</span>&nbsp;</a></li><li class=nav-item><a class=nav-link data-nav=main data-nav-main=tags href=/tags><span>Tags</span>&nbsp;</a></li><li class="d-flex mode-switch align-items-center" id=navbar-mode><input type=checkbox class="checkbox navbar-mode-selector" id=navbar-mode-checkbox aria-label="Toggle theme">
<label class=label for=navbar-mode-checkbox><svg class="svg-inline--fa fas fa-sun fa-fw" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 512 512"><use href="#fas-sun"/></svg><svg class="svg-inline--fa fas fa-moon fa-fw" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 384 512"><use href="#fas-moon"/></svg><div class=ball></div></label></li></ul></div></div></nav></div><div class=main-content></div></div><div class="container-xxl flex-fill p-4 px-xxl-0"><div class="row row-cols-1 row-cols-md-2 row-cols-lg-3"><div class="col col-lg-2 d-none d-lg-block sidebar-overflow sticky-top pt-5"></div><div class="col-12 col-md-9 col-lg-8 mb-5 p-4"><nav aria-label=breadcrumb class=d-sm-none><ol class=breadcrumb><li class=breadcrumb-item><a href=/blogs/><svg class="svg-inline--fa fas fa-angle-left" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 320 512"><use href="#fas-angle-left"/></svg>&nbsp;&nbsp;Blogs</a></li></ol></nav><nav aria-label=breadcrumb class="d-none d-sm-block"><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/blogs/>Blogs</a></li><li class="breadcrumb-item active" aria-current=page>LSH</li></ol></nav><p class="display-4 mt-5">LSH</p><small class="text-body-secondary text-uppercase">Posted on June 17, 2024
&bull;
5&nbsp;min read &bull;
1,022&nbsp;words</small><p class="lead mb-5 mt-3">LSH (Locality-Sensitive Hashing, 局部敏感哈希) 算法</p><div class="d-md-none pb-5"><div class="d-grid gap-2 mx-auto"><a aria-label="On this page" href=#toc-collapse class="btn btn-outline-secondary position-relative toc-button" data-bs-toggle=collapse aria-expanded=false aria-controls=toc-collapse role=button><span class="d-flex justify-content-between"><span class=my-auto>On this page</span><span class="align-self-center ps-1"><svg class="svg-inline--fa fas fa-sort" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 320 512"><use href="#fas-sort"/></svg></span></span></a></div><div class="collapse border bg-body-tertiary rounded p-1 navbar-nav-scroll" id=toc-collapse><small><div class="toc toc-panel text-body p-2"><a class="toc-item toc-level-1" href=/blogs/lsh/#hash>Hash </a><a class="toc-item toc-level-1" href=/blogs/lsh/#lsh>LSH </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-1-shingling>Step 1: Shingling </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-2-min-hashing>Step 2: Min-Hashing </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-3-locality-sensitive-hashing>Step 3: Locality Sensitive Hashing </a><a class="toc-item toc-level-1" href=/blogs/lsh/#summary>Summary </a><a class="toc-item toc-level-2" href=/blogs/lsh/#summary-1>Summary </a><a class="toc-item toc-level-2" href=/blogs/lsh/#lsh的一般定义>LSH的一般定义</a></div></small></div></div><div class=content><p>在 <strong>Top N 推荐</strong>中，我们需要处理的是大量高维度的数据，如何快速地从大量的高维度数据集中找出与某条数据最为接近的一条或多条数据成为了难题。</p><p>如果只是一些小规模的低维度数据集，可以很容易地使用线性搜索来解决问题；但如果我们要在一个庞大的高维度数据集中使用线性搜索来进行匹配，则会消耗很多时间。</p><p>因此，需要采取一些类似于索引的技术来加速查询过程，这些技术通常被统称为 <strong>最近邻查找 (Nearest Neighbor, <code>NN</code>)</strong> ，而在处理大规模数据时，还可以考虑采用 <strong>近似最近邻查找 (Approximate Nearest Neighbor, <code>ANN</code>)</strong>。其中一种常用的方法就是<strong>局部敏感哈希 (Locality-Sensitive Hashing, <code>LSH</code>)</strong>。</p><h2 id=hash class=heading>Hash<a href=#hash aria-labelledby=hash><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h2><p><code>Hash</code>一般翻译做 <strong>散列</strong>，就是把任意长度的输入（又叫做 <strong>预映射</strong>， <strong>pre-image</strong>），通过散列算法，变换成固定长度的输出，该输出就是散列值。</p><p>这种转换是一种<strong>压缩映射</strong>，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出。</p><p>通俗的说 <strong>Hash就是找到一种数据内容和数据存放地址之间的映射关系</strong>（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">y</mi></mrow><mo>→</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">s</mi></mrow></mrow><annotation encoding="application/x-tex">f: \mathrm{key} \rightarrow \mathrm{address}</annotation></semantics></math></span>
</span>）。</p><h2 id=lsh class=heading>LSH<a href=#lsh aria-labelledby=lsh><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h2><p>传统的哈希表用于检索数据，无法将相似的数据放到同一个Bucket中，比如
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>x</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>w</mi></mrow><annotation encoding="application/x-tex">h=x \mod w</annotation></semantics></math></span>
</span>；</p><p><strong>LSH将相邻的数据，通过映射后依然保持相邻的关系，即保持局部的敏感度Locality-Sensitive</strong>。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/0.png width=55% alt></center><p><code>LSH</code>通过哈希函数，将原始数据集划分为若干<strong>子集（Bucket）</strong>，每个子集中包含的数据很可能彼此相邻，并且这些子集中的元素数量相对较小。这使得可以在一个小的集合中搜索临近的元素，从而实现快速最近邻查询。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231015393.png width=55% alt></center><ol><li><p><strong>Shingling</strong>: 将文档转化为集合形式(<code>bool</code> 值)</p></li><li><p><strong>Min-Hashing</strong>: 将较大的数据集转化为相对更短的<code>signatures</code>，同时保证每对数据的相关性。</p></li><li><p><strong>Locality-Sensitive Hashing</strong></p></li></ol><h3 id=step-1-shingling class=heading>Step 1: Shingling<a href=#step-1-shingling aria-labelledby=step-1-shingling><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h3><p>将文档转化为集合形式。</p><p>文档的 <code>k-shingle</code>（或 <strong><code>k-gram</code></strong>）是指文档中出现的一串长度为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span>
</span>的 token序列</p><ul><li>token可以是字符、词或者其他形式，这取决于应用的具体情况，例如可以假设：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">s</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{tokens} = \mathrm{characters}</annotation></semantics></math></span></span></li></ul><p>为了压缩较长的 shingles，我们可以把他们 hash 成（例如）<code>4bytes</code>， 通过该文档所有 <code>k-shingels</code> 的哈希值集来表示这个文档。</p><hr><p><strong>Example:</strong></p><ul><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span>
</span>;</p></li><li><p>Doc：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>=</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi></mrow></mrow><annotation encoding="application/x-tex">D_1= \mathrm{abcab}</annotation></semantics></math></span>
</span>;</p></li><li><p>2-shingles set of Doc
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>:</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi></mrow><mo separator="true">,</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">c</mi></mrow><mo separator="true">,</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_1: S(D_1)= \{\mathrm{ab}, \mathrm{bc}, \mathrm{ca}\}</annotation></semantics></math></span></span></p></li></ul><p>Hash the shingles:
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">h(D_1) = \{1, 5, 7\}</annotation></semantics></math></span></span></p><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">k = 8, 9, 10</annotation></semantics></math></span>
</span>is often used in practice</p><hr><p><strong>Shingles 的优势</strong></p><ul><li>类似的文档会有许多共有的 shingle（碎片）</li><li>改变一个词只会影响该词距离k-1以内的 k-gram</li></ul><p>文档
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span>
</span>被它自己的 k-grams 集合
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_i = S(D_i)</annotation></semantics></math></span>
</span>所代表。</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\mathrm{sim}(D_1, D_2) = \frac{|C_1 \cap C_2|}{|C_1 \cup C_2|}
</annotation></semantics></math></span></div><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\mathrm{d}(C_1, C_2) =1- \frac{|C_1 \cap C_2|}{|C_1 \cup C_2|}
</annotation></semantics></math></span></div><p><strong>用 0/1（bit, Boolean）向量来编码集合并生成相应的特征矩阵。</strong></p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231134586.png width=15% alt></center><ul><li><p>Rows : <code>k-grams</code></p></li><li><p>Columns ： 文档集合，每一列代表一个文件</p><ul><li><p>第
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span>
</span>行第
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span>
</span>列中 元素值为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>
</span>当且仅当 <code>k-gram</code>
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span>
</span>是 文档
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span>
</span>的一部分</p></li><li><p><strong>列相似性</strong>是相应集合的 <code>Jaccard </code>相似度（<strong>具有值 1 的行</strong>）</p></li><li><p>矩阵是稀疏的</p></li></ul></li></ul><h3 id=step-2-min-hashing class=heading>Step 2: Min-Hashing<a href=#step-2-min-hashing aria-labelledby=step-2-min-hashing><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h3><p>将较大的数据集转化为相对更短的 <code>signatures</code>，同时保证每对数据的相关性。</p><blockquote class=blockquote><p><strong>Key Idea:</strong></p><p>将每一列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span>
</span>hash 至更短的 <code>signature</code>
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(C)</annotation></semantics></math></span>
</span>，使得：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{sim}(C_1 ,C_2 )</annotation></semantics></math></span>
</span>与 signatures
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(C_1)</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(C_2)</annotation></semantics></math></span>
</span>的相似度一致</p></blockquote><p><strong>Goal:</strong></p><p><strong>找到一个散列函数
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(\cdot)</annotation></semantics></math></span>
</span>使得：</strong></p><ul><li>如果
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{sim}(C_1 ,C_2 )</annotation></semantics></math></span>
</span>很大，那么
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(C_1 ) = h(C_2)</annotation></semantics></math></span>
</span>的概率很大</li><li>如果
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{sim}(C_1 ,C_2 )</annotation></semantics></math></span>
</span>很小，那么
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(C_1 ) = h(C_2)</annotation></semantics></math></span>
</span>的概率很小</li></ul><p><strong>Idea:</strong></p><p>将文档<code>hash</code>进 buckets，期望“大部分”近似重复的文档被散列到相同的桶中。</p><h4 id=min-hashing class=heading>Min-Hashing<a href=#min-hashing aria-labelledby=min-hashing><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h4><ol><li>使用某个<strong>变换</strong>
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span>
</span>来变换 Boolean 矩阵的行。</li><li>对于该变换，定义<strong>min-hash 函数</strong>：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_\pi(C)</annotation></semantics></math></span>
</span>= 第
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span>
</span>列中值为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>
</span>的第一个行号 （变换后的顺序）。</li></ol><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mrow><mi>min</mi><mo>⁡</mo></mrow><mi>π</mi></munder><mi>π</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
h_\pi(C) = \min_\pi \pi(C)
</annotation></semantics></math></span></div><ol start=3><li><p>将
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>π</mi></msub></mrow><annotation encoding="application/x-tex">h_{\pi}</annotation></semantics></math></span>
</span>应用到每一列上，从而得到每列的一个<code>signature</code>（特征向量)。</p></li><li><p>将文档集合转化为 <strong>signature 矩阵
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span>
</span></strong>:</p><ul><li><p>Columns ：文档集合</p></li><li><p>Rows ：对每一个变换
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span>
</span>对应的最小化散列值</p></li></ul></li></ol><hr><p><strong>[Example]</strong></p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231340153.png width=55% alt></center><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231520619.png width=35% alt>
<img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231504997.png width=35% alt></center><hr><p><strong>[证明1]</strong></p><p>选择一个随机排列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span>
</span>, 证明
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Pr}\Big[h_{\pi}(C_1) = h_{\pi} (C_2)\Big] = \mathrm{sim}(C_1 , C_2 )</annotation></semantics></math></span>
</span>。</p><ul><li>令
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span>
</span>为 doc，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">z \in X</annotation></semantics></math></span>
</span>为 shingle， 则有：</li></ul><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>π</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align}
\mathrm{Pr}\Big[\pi(z)= \min(\pi(X))\Big] = \frac{1}{|X|})
\end{align}
</annotation></semantics></math></span></div><p>因为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\forall z \in X</annotation></semantics></math></span>
</span>等可能地映射到最小值
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span></span></p><ul><li><p>令
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\mathbf y</annotation></semantics></math></span>
</span>为 shingles 集合，使得
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(\mathbf y) := \min(\pi(C_1\cup C_2 ))</annotation></semantics></math></span>
</span>, 则：</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>π</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><mrow><mtext>if </mtext><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">y</mi><mo>∈</mo><msub><mi>C</mi><mn>1</mn></msub></mstyle><mtext> </mtext></mrow><mspace width="1em"/><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><mi mathvariant="normal">∅</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>or</mtext><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>π</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><mrow><mtext>if </mtext><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">y</mi><mo>∈</mo><msub><mi>C</mi><mn>2</mn></msub></mstyle><mtext> </mtext></mrow><mspace width="1em"/><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mi mathvariant="normal">∅</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">
    \begin{align}
    &amp;\pi(\mathbf y)=\min(\pi(C_1)) , \quad \text{if $\mathbf y \in C_1$ } \quad(C_2 = \emptyset )\\ 
    \text{or} \quad &amp;\pi(\mathbf y)=\min(\pi(C_2)) ,\quad \text{if $\mathbf y \in C_2$ } \quad (C_1 = \emptyset )
    \end{align}
    </annotation></semantics></math></span></div><p>那么</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="1em"/><mrow><mtext>if </mtext><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">y</mi><mo>∈</mo><msub><mi>C</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>C</mi><mn>2</mn></msub></mstyle><mtext> </mtext></mrow></mrow><annotation encoding="application/x-tex">
    \pi(\mathbf y)=\min(\pi(C_1))=\min(\pi(C_2)) \quad \text{if $\mathbf y \in C_1 \cap C_2$ }
    </annotation></semantics></math></span></div></li><li><p>所以</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">
    \begin{align}
    \mathrm{Pr}\Big[\min(\pi(C_1)) = \min(\pi (C_2))\Big] = \frac{|C_1 \cap C_2|}{|C_1 \cup C_2|}= \mathrm{sim}(C_1 , C_2 )
    \end{align}
    </annotation></semantics></math></span></div></li></ul><hr><p><strong>[证明2]</strong></p><p>对于
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span>
</span>,
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span>
</span>两列， 对应行有
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span>
</span>种可能：</p><ol><li>【Type A】两列的值都为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>
</span>，数量为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></li><li>【Type B】其中一列的值为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span>
</span>，另一列的值为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>
</span>, 数量为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></span></li><li>【Type C】两列的值都为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span>
</span>，数量为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span></span></li></ol><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>a</mi><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\mathrm{sim}(C_1 , C_2 ) = \frac{a}{a+b}
</annotation></semantics></math></span></div><p>【Type C】对于结果计算没有影响，可以删除</p><p>又因为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_{\pi}(C_1) = h_{\pi} (C_2)</annotation></semantics></math></span>
</span>当且仅当 对应的行为【Type A】</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><mfrac><mi>a</mi><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow></mfrac><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\mathrm{Pr}\Big[h_{\pi}(C_1) = h_{\pi} (C_2)\Big] = \mathrm{Pr}\Big[ \frac{a}{a+b}\Big] =
 \mathrm{sim}(C_1 , C_2 )
</annotation></semantics></math></span></div><hr><p>两个<code>signature</code>之间的相似度是它们的 <strong>min-hash function</strong> 中达成一致的比例，也即它们表示的列（或集合）的 <strong>Jaccard相似度</strong>。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311231815033.png width=55% alt></center><p>1-3：</p><ul><li><p>col/col:
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mn>4</mn></mfrac><mo>=</mo><mn>0.75</mn></mrow><annotation encoding="application/x-tex">\frac{3}{4} = 0.75</annotation></semantics></math></span>
</span>(input matrix)</p></li><li><p>sig/sig:
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac><mo>=</mo><mn>0.67</mn></mrow><annotation encoding="application/x-tex">\frac{2}{3} = 0.67</annotation></semantics></math></span>
</span>(signature matrix)</p></li></ul><h4 id=执行技巧 class=heading>执行技巧<a href=#%e6%89%a7%e8%a1%8c%e6%8a%80%e5%b7%a7 aria-labelledby=执行技巧><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h4><ul><li><p>对于每一列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>
</span>和 每一个hash函数
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span>
</span>，记录
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(i,c)</annotation></semantics></math></span>
</span>, 初始化
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">M(i, c) = \infin</annotation></semantics></math></span></span></p></li><li><p>对行进行扫描，如果列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>
</span>在 第
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span>
</span>行存在
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>
</span>, 那么对每个
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span>
</span>如果
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_i(j) &lt; M(i, c)</annotation></semantics></math></span>
</span>, 则用
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>←</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(i, c) \larr h_i (j)</annotation></semantics></math></span>
</span>。（即如果此时列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>
</span>上 第
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span>
</span>行的元素为1，通过
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span>
</span>得到最新的行号，而且新行号比原来记录的
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span>
</span>值小，那么更新M值。）</p></li></ul><p><strong>hash函数获取</strong></p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>x</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">
h_{a,b}(x)=((a \cdot x+b) \mod p) \mod N
</annotation></semantics></math></span></div><ul><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>
</span>,
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>：随机整数</li><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>
</span>：质数 (
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">p &gt; N</annotation></semantics></math></span>
</span>)</li></ul><hr><p><strong>Example</strong></p><ul><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>5</mn></mrow><annotation encoding="application/x-tex">h_1(x)= x \mod 5</annotation></semantics></math></span></span></li><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>5</mn></mrow><annotation encoding="application/x-tex">h_2(x)=(2x+1) \mod 5</annotation></semantics></math></span></span></li></ul><table class=table><thead><tr><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_2</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(h_1,c_1)</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(h_2,c_1)</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(h_1,c_2)</annotation></semantics></math></span></span></th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(h_2,c_2)</annotation></semantics></math></span></span></th></tr></thead><tbody><tr><td>1</td><td>0</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_1(1) =1</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">h_2(1) =3</annotation></semantics></math></span></span></td><td>1</td><td>3</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infin</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infin</annotation></semantics></math></span></span></td></tr><tr><td>0</td><td>1</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">h_1(2) =2</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h_2(2) =0</annotation></semantics></math></span></span></td><td>1</td><td>3</td><td>2</td><td>0</td></tr><tr><td>1</td><td>1</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">h_1(3) =3</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">h_2(3) =2</annotation></semantics></math></span></span></td><td>1</td><td>2</td><td>2</td><td>0</td></tr><tr><td>1</td><td>0</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">h_1(4) =4</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">h_2(4) =4</annotation></semantics></math></span></span></td><td>1</td><td>2</td><td>2</td><td>0</td></tr><tr><td>0</td><td>1</td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h_1(5) =0</annotation></semantics></math></span></span></td><td><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_2(5) =1</annotation></semantics></math></span></span></td><td>1</td><td>2</td><td>0</td><td>0</td></tr></tbody></table><hr><h3 id=step-3-locality-sensitive-hashing class=heading>Step 3: Locality Sensitive Hashing<a href=#step-3-locality-sensitive-hashing aria-labelledby=step-3-locality-sensitive-hashing><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h3><blockquote class=blockquote><p>Focus on pairs of signatures likely to be from similar documents</p></blockquote><p>除了要解决
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span>
</span>两两之间相似度的计算问题，当数据量大（>100万）的时候，两两之间相似度计算次数为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>c</mi><mi>N</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">c^2_N</annotation></semantics></math></span>
</span>，计算量非常大。</p><p>为了解决这一问题，将可能相似的用户以较大概率分到同一个bucket内，这样，同一个bucket中的列，两两之间才进行相似度计算，而不是所有列两两之间进行相似度计算，大大降低计算复杂度。</p><p><strong>hash 函数数目</strong>和 <strong>bucket数目</strong>的协调：</p><p>为了使每个bucket中的<code>signatures</code>数目相对较少，从而生成较少的候选pairs，我们需要调整 hash 函数和每个 hash 函数的 buckets 数目。</p><p>但是也不能使用太多的buckets，否则真正相似的pairs都不会被任意一个hash函数聚到同一个bucket中。</p><h4 id=lsh具体做法 class=heading>LSH具体做法<a href=#lsh%e5%85%b7%e4%bd%93%e5%81%9a%e6%b3%95 aria-labelledby=lsh具体做法><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h4><ol><li><p>将 signature 矩阵
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span>
</span>按行划分为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span><code>bands</code>，每个band宽度为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>行。</p></li><li><p>把每个band hash到一些bucket中（<strong>不同的band使用不同的hash函数</strong>，也就是对每个band我们都要创建一个hash函数）。</p><ul><li><strong>只要两个signatures在某个片断band上的 Min-Hash 相同</strong>，它们在整体上就有一定的概率相似，那么这两者就会hash到同一个桶而成为候选相似 项。</li><li><strong>同一个bucket中的两列是局部相似的</strong>（因为只要某个band相似就会至少hash一次到同一个bucket中（局部敏感哈希）），所以同一个bucket中的任意两对都是候选对。</li><li>如果两个<code>signatures</code>大部分都是相同的，那么存在bands 100%相同就有很大的机会。而两列如果不相似，即很少有相同的片段，那他们被hash到同一个bucket中的概率就相当小，只要bucket的数量要足够多，两个不一样的bands就会被哈希到不同的bucket中。</li></ul></li></ol><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:.5rem" src=pics/image-20250311232144925.png width=40% alt>
<img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:.5rem" src=pics/image-20250311232224653.png width=36% alt></center><h4 id=lsh准确率分析 class=heading>LSH准确率分析<a href=#lsh%e5%87%86%e7%a1%ae%e7%8e%87%e5%88%86%e6%9e%90 aria-labelledby=lsh准确率分析><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h4><ul><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span>
</span>：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span>
</span>个sets ( docs、columns、signatures) 的<strong>真实相似度</strong></li><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>：<strong>相似度阈值</strong>。</li></ul><p><strong>理想阶跃函数</strong>：</p><ul><li>当两个 sets <strong>相似度高</strong>时（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">&gt;t</annotation></semantics></math></span>
</span>），总是<strong>分到同一个bucket</strong>中，</li><li>当两个 sets <strong>相似度低</strong>时（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">&lt;t</annotation></semantics></math></span>
</span>），总是<strong>不会分到同一个bucket</strong>中（分到同一bucket中的概率为0）</li></ul><p><strong>实际情况</strong>: 分析signature matrix 的单行（两列） 阈值为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>时的
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">FP</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>。</p><ul><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">FP</annotation></semantics></math></span>
</span>：相似度阈值
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>小但是分到同一buckets中的概率</li><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>：相似度阈值
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>大但是未分到同一buckets中的概率</li></ul><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:.5rem" src=pics/image-20250311232428567.png width=40% alt>
<img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:.5rem" src=pics/image-20250311232456978.png width=38% alt><br><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:.5rem" src=pics/image-20250311232518743.png width=46% alt></center><p><strong>具体分析</strong></p><p>假设对于某行，两列
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>,
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>Signature值相同的概率为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>（两列的相似度）</p><ul><li><p>对于某个band（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>行）</p><ul><li><p>其中所有行，值相同的概率为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">t^r</annotation></semantics></math></span></span></p></li><li><p>存在至少一行值不相同的概率为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">1-t^r</annotation></semantics></math></span></span></p></li></ul></li><li><p>对于
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>个band，每个band 都至少存在一行值不相同的概率为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">(1-t^r)^b</annotation></semantics></math></span>
</span>。<strong>【
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>不会被分到同一个bucket】</strong></p></li><li><p>对于
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>个band，至少存在一个band值相同（即至少存在一组相似对）的概率为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">1- (1-t^r)^b</annotation></semantics></math></span>
</span>。<strong>【
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>会被分到至少同一个bucket】</strong></p></li></ul><hr><p><strong><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">FP</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>的概率大小控制</strong></p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311232911691.png width=45% alt></center><ul><li><p>signatures 长度固定
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span>
</span>时</p><ul><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>越大，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mfrac><mi>M</mi><mi>b</mi></mfrac></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">(1-t^r)^b = (1-t^{\frac{M}{b}}) ^b </annotation></semantics></math></span>
</span>越小。S曲线就越接近于阶跃函数（折线）。因此在min-hash阶段使用越多 hash 函数，可以使 LSH 阶段的错误更小一些。</li><li><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>越大，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mfrac><mi>M</mi><mi>r</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">(1-t^r)^b = (1-t^{r}) ^{\frac{M}{r}} </annotation></semantics></math></span>
</span>越大。S曲线就越接近于斜线。</li></ul></li><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>固定时</p><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">1-(1-t^r)^b</annotation></semantics></math></span>
</span>（<strong>阈值
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>下相似的列hash到至少同一个桶中的概率</strong>）的增长类似一个<strong>阶跃函数step function</strong>，当阈值在大概
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>b</mi></mfrac><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>r</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">t = (\frac{1}{b})^{\frac{1}{r}}</annotation></semantics></math></span>
</span>这个位置时跳跃。</p><p>输入一个相似度
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>，得到一个概率
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>
</span>（hash到同一个bucket中的概率）。当相似度变大时，其hash到同一个bucket中的概率也变大，反之相似度变小时，其hash到同一个bucket中的概率变小。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311233218561.png width=45% alt></center><p>下表为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">b=20</annotation></semantics></math></span>
</span>,
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">r=5</annotation></semantics></math></span>
</span>时的概率表，从表中看出，0.4-0.6之间的跳跃最大，幅度超过0.6，threshold取值在这个范围内最优。</p><table class=table><thead><tr><th>t</th><th><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>t</mi><mi>r</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">1-(1-t^r)^b</annotation></semantics></math></span></span></th></tr></thead><tbody><tr><td>0.2</td><td>0.0064</td></tr><tr><td>0.3</td><td>0.0475</td></tr><tr><td>0.4</td><td>0.1860</td></tr><tr><td>0.5</td><td>0.4701</td></tr><tr><td>0.6</td><td>0.8019</td></tr><tr><td>0.7</td><td>0.9748</td></tr><tr><td>0.8</td><td>0.9996</td></tr></tbody></table></li></ul><hr><p><strong>Example</strong></p><p>假设
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span>
</span>有100000列（100k个文档），签名长度为100，查找相似度至少达到
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.8</mn></mrow><annotation encoding="application/x-tex">0.8</annotation></semantics></math></span>
</span>的两篇文档。</p><ul><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">b=20</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">r =5</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0.8</mn></mrow><annotation encoding="application/x-tex">\mathrm{sim}(C_1 , C_2 ) = 0.8</annotation></semantics></math></span></span></p><ul><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>在某个band中值完全一致的概率为：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0.8</mn><msup><mo stretchy="false">)</mo><mn>5</mn></msup><mo>=</mo><mn>0.328</mn></mrow><annotation encoding="application/x-tex">(0.8)^5 = 0.328</annotation></semantics></math></span></span></p></li><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>在
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>个band中均不存在值完全一致的概率为：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.328</mn><msup><mo stretchy="false">)</mo><mn>20</mn></msup><mo>=</mo><mn>0.00035</mn></mrow><annotation encoding="application/x-tex">(1-0.328)^{20} = 0.00035</annotation></semantics></math></span></span></p></li><li><p>因此，约有
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.035</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">0.035\%</annotation></semantics></math></span>
</span>的
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>80</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">80\%</annotation></semantics></math></span>
</span>相似度的文档对会被认为是不相关的（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>）， 我们将会找到
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>99.965</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">99.965\%</annotation></semantics></math></span>
</span>真实为相似对的文档对。</p></li></ul></li><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">b=20</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">r =5</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0.3</mn></mrow><annotation encoding="application/x-tex">\mathrm{sim}(C_1 , C_2 ) = 0.3</annotation></semantics></math></span></span></p><ul><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>在某个band中值完全一致的概率为：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0.3</mn><msup><mo stretchy="false">)</mo><mn>5</mn></msup><mo>=</mo><mn>0.0024</mn></mrow><annotation encoding="application/x-tex">(0.3)^5 = 0.0024</annotation></semantics></math></span></span></p></li><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>在
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>个band中均不存在值完全一致的概率为：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.0024</mn><msup><mo stretchy="false">)</mo><mn>20</mn></msup><mo>=</mo><mn>0.9525</mn></mrow><annotation encoding="application/x-tex">(1-0.0024)^{20} = 0.9525</annotation></semantics></math></span></span></p></li><li><p><span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span>
</span>在
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>个band中至少存在一个值完全一致的概率为：
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.0024</mn><msup><mo stretchy="false">)</mo><mn>20</mn></msup><mo>=</mo><mn>0.0474</mn></mrow><annotation encoding="application/x-tex">1- (1-0.0024)^{20} = 0.0474</annotation></semantics></math></span></span></p></li><li><p>因此，约有
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4.74</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">4.74\%</annotation></semantics></math></span>
</span>的
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span>
</span>相似度的文档对会被认为是相关的（
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">FP</annotation></semantics></math></span>
</span>）， 我们将会误把
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4.74</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">4.74\% </annotation></semantics></math></span>
</span>的不相关文档 当做相似文档对。</p></li></ul></li></ul><hr><p><strong>在LSH算法使用过程中，我们需要确定</strong>:</p><ol><li><p><strong>相似度阈值</strong>
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>，相似用户的阈值定义（近邻定义）；</p></li><li><p><strong>Signature向量的长度</strong>，降到
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span>
</span>维 embedding。</p><p>针对
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>的取值，我们需要考虑：</p><ul><li><p>如果想要尽可能少的出现
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>，需要选择
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>使得概率变化最陡的地方小于
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>（比如
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>
</span>在
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span>
</span>以上才属于相似用户，选择
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>使得S曲线的最陡处小于
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span>
</span>）；</p></li><li><p>如果想要保证计算速度较快，并且尽可能少出现
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">FN</annotation></semantics></math></span>
</span>，那么最好选择
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>
</span>和
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span>
</span>使得概率变化最陡的地方较大（比如
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">b=20</annotation></semantics></math></span>
</span>，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">r=6</annotation></semantics></math></span>
</span>）这样，
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span>
</span>较小的两个列就很难成为candidate列，但同时也会有一些“潜在”的相似用户不会被划分到同一个桶内。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311234013852.png width=45% alt></center></li></ul></li></ol><h2 id=summary class=heading>Summary<a href=#summary aria-labelledby=summary><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h2><h3 id=summary-1 class=heading>Summary<a href=#summary-1 aria-labelledby=summary-1><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h3><ol><li><p><code>Shingling</code>:</p><p>将文档转换为集合表示， 使用 hash 函数给每一块 shingling 赋予一个唯一的标识符</p></li><li><p><code>Min-Hashing</code>：<strong>特征降维</strong></p><p>将文档集合表示转化为更短的signatures矩阵，同时保证其文档间的相似度不变。</p><ul><li><p>使用保持相似性的 hash 函数来生成signatures矩阵，维持其特定性质</p><div class=mathjax-display><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">[</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>π</mi></msub><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">]</mo><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
     \mathrm{Pr}\Big[h_{\pi}(C_1) = h_{\pi} (C_2)\Big] = \mathrm{sim}(C_1 , C_2)
     </annotation></semantics></math></span></div></li><li><p>使用 hash 函数取代生成随机变换</p></li></ul></li><li><p><code>Locality-Sensitive Hashing</code>：<strong>分桶</strong>（<strong>数据规模N的“降维”，减少查找范围）</strong></p><p>关注可能是来自于相似文档的签名对，使用 hashing 找出相似度
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">\ge s</annotation></semantics></math></span>
</span>的候选配对</p></li></ol><h3 id=lsh的一般定义 class=heading>LSH的一般定义<a href=#lsh%e7%9a%84%e4%b8%80%e8%88%ac%e5%ae%9a%e4%b9%89 aria-labelledby=lsh的一般定义><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h3><p>函数
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">{h\colon M\to S}</annotation></semantics></math></span>
</span>的有限族
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\mathcal F</annotation></semantics></math></span>
</span>被定义为 <strong>LSH族</strong>，如果存在</p><ul><li>度量空间
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal {M}=(M,d)</annotation></semantics></math></span></span></li><li>阈值
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r&gt;0</annotation></semantics></math></span></span></li><li>近似因子
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c&gt;1</annotation></semantics></math></span></span></li><li>概率
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_1&gt;p_2</annotation></semantics></math></span></span></li></ul><p>对于任何两个点
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">a,b\in M</annotation></semantics></math></span>
</span>和从
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\mathcal F</annotation></semantics></math></span>
</span>中均匀随机选择的散列函数
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span>
</span>, 如果它满足以下条件:</p><ul><li>如果
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">d(a,b)\leq r</annotation></semantics></math></span>
</span>，则
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(a) = h(b)</annotation></semantics></math></span>
</span>的概率至少为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span>
</span>，即
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo>≥</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P\big(h(a)=f(b)\big) \ge p_1</annotation></semantics></math></span></span></li><li>如果
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>c</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">d(a,b)\ge cr</annotation></semantics></math></span>
</span>，则
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(a) = h(b)</annotation></semantics></math></span>
</span>的概率至多为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span>
</span>，即
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo>≤</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P\big(h(a)=f(b)\big) \le p_2</annotation></semantics></math></span></span></li></ul><p>这样的有限族
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\mathcal F</annotation></semantics></math></span>
</span>被称为
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>c</mi><mi>r</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r,cr,p_1,p_2)</annotation></semantics></math></span>
</span><strong>-sensitive的函数簇</strong>。</p><center><img style="border-radius:.3125em;box-shadow:0 .2rem .4rem rgba(34,36,38,.12);margin:1rem" src=pics/image-20250311234351732.png width=45% alt></center><p><strong>Jaccard 相似性</strong>对应的 <code>LSH</code> 为 MinHash 是
<span class=mathjax-inline><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mn>1</mn><mo>−</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mn>1</mn><mo>−</mo><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,1-d_1,1-d_2)</annotation></semantics></math></span>
</span>-sensitive。</p><h1 id=reference class=heading>Reference<a href=#reference aria-labelledby=reference><svg class="svg-inline--fa fas fa-link anchor" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 640 512"><use href="#fas-link"/></svg></a></h1><ul><li><a href=https://web.stanford.edu/class/cs246/slides/03-lsh.pdf class=markdown-link>https://web.stanford.edu/class/cs246/slides/03-lsh.pdf</a></li><li><a href=https://web.stanford.edu/class/cs246/slides/04-lsh_theory.pdf class=markdown-link>https://web.stanford.edu/class/cs246/slides/04-lsh_theory.pdf</a></li><li><a href=https://alice1214.github.io/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/2020/08/03/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%B8%89-LSH-%E8%BF%91%E4%BC%BC%E6%9C%80%E8%BF%91%E9%82%BB%E6%9F%A5%E6%89%BE/ class=markdown-link>推荐算法学习（十三）：LSH近似最近邻查找</a></li></ul></div><div class="row row-cols-2 mt-5 mb-3"><div class=col><a class=next href=/blogs/rope/><svg class="svg-inline--fa fas fa-arrow-left" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 448 512"><use href="#fas-arrow-left"/></svg>&nbsp;RoPE</a></div><div class="col text-end"><a class=previous href=/blogs/flashattention/>FlashAttention&nbsp;<svg class="svg-inline--fa fas fa-arrow-right" fill="currentcolor" aria-hidden="true" role="img" viewBox="0 0 448 512"><use href="#fas-arrow-right"/></svg></a></div></div><a href=# id=back-to-top class=back-to-top><span>▲</span>
</a><a href=# id=scroll-to-bottom class=back-to-top><span>▼</span>
</a><script>document.addEventListener("DOMContentLoaded",function(){var e=document.getElementById("back-to-top"),t=document.getElementById("scroll-to-bottom");e.addEventListener("click",function(e){e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})}),t.addEventListener("click",function(e){e.preventDefault(),window.scrollTo({top:document.body.scrollHeight,behavior:"smooth"})})})</script></div><div class="col col-md-3 col-lg-2 d-none d-md-block pt-5"><div class="toc toc-sidebar mb-5 my-md-0 mb-lg-5 p-3 text-body-secondary sticky-top"><strong class="d-block h6 my-2 pt-4">On this page:</strong><nav class=toc><a class="toc-item toc-level-1" href=/blogs/lsh/#hash>Hash </a><a class="toc-item toc-level-1" href=/blogs/lsh/#lsh>LSH </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-1-shingling>Step 1: Shingling </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-2-min-hashing>Step 2: Min-Hashing </a><a class="toc-item toc-level-2" href=/blogs/lsh/#step-3-locality-sensitive-hashing>Step 3: Locality Sensitive Hashing </a><a class="toc-item toc-level-1" href=/blogs/lsh/#summary>Summary </a><a class="toc-item toc-level-2" href=/blogs/lsh/#summary-1>Summary </a><a class="toc-item toc-level-2" href=/blogs/lsh/#lsh的一般定义>LSH的一般定义</a></nav></div></div></div></div><footer class="container-fluid footer text-center p-3"><div class="container-xxl text-center"><small>Copyright © 2025 EV's Blog All rights reserved.
|
Powered by
<a href=https://gethinode.com class="link-bg-footer markdown-link">Hinode</a>.</small></div></footer></div><div id=toast-container class="toast-container position-fixed bottom-0 end-0 p-3"><div id=toast-copied-code-message class=toast role=alert aria-live=assertive aria-atomic=true><div class=toast-header><strong class=me-auto>EV's Blog</strong>
<button type=button class=btn-close data-bs-dismiss=toast aria-label=Close></button></div><div class=toast-body>Code copied to clipboard</div></div></div><svg xmlns:xlink="http://www.w3.org/1999/xlink" display="none"><symbol id="fas-ellipsis"><path d="M8 256a56 56 0 11112 0A56 56 0 118 256zm160 0a56 56 0 11112 0 56 56 0 11-112 0zm216-56a56 56 0 110 112 56 56 0 110-112z"/></symbol><symbol id="fas-sun"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 11192 0 96 96 0 11-192 0zm224 0a128 128 0 10-256 0 128 128 0 10256 0z"/></symbol><symbol id="fas-moon"><path d="M223.5 32C1e2 32 0 132.3.0 256S1e2 480 223.5 480c60.6.0 115.5-24.2 155.8-63.4 5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6-96.9.0-175.5-78.8-175.5-176 0-65.8 36-123.1 89.3-153.3 6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></symbol><symbol id="fas-angle-left"><path d="M41.4 233.4c-12.5 12.5-12.5 32.8.0 45.3l160 160c12.5 12.5 32.8 12.5 45.3.0s12.5-32.8.0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8.0-45.3s-32.8-12.5-45.3.0l-160 160z"/></symbol><symbol id="fas-sort"><path d="M137.4 41.4c12.5-12.5 32.8-12.5 45.3.0l128 128c9.2 9.2 11.9 22.9 6.9 34.9S301 224.1 288 224.1L32 224c-12.9.0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9l128-128zm0 429.3-128-128c-9.2-9.2-11.9-22.9-6.9-34.9S19.1 288 32.1 288h256c12.9.0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-128 128c-12.5 12.5-32.8 12.5-45.3.0z"/></symbol><symbol id="fas-arrow-left"><path d="M9.4 233.4c-12.5 12.5-12.5 32.8.0 45.3l160 160c12.5 12.5 32.8 12.5 45.3.0s12.5-32.8.0-45.3L109.2 288H416c17.7.0 32-14.3 32-32s-14.3-32-32-32H109.3L214.6 118.6c12.5-12.5 12.5-32.8.0-45.3s-32.8-12.5-45.3.0l-160 160z"/></symbol><symbol id="fas-arrow-right"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></symbol></svg>
<script src=/js/core.bundle-analytics.en.min.ceb6a67c169a28031391976dac91e1e2f460951862201b6249516a55d0fd6109.js data-category=analytics integrity="sha256-zramfBaaKAMTkZdtrJHh4vRglRhiIBtiSVFqVdD9YQk=" crossorigin=anonymous async></script><script src=/js/core.bundle.en.min.61d422f277782351975f4db20ef2a166f8d70933660f72b11ad8399e5cd40497.js integrity="sha256-YdQi8nd4I1GXX02yDvKhZvjXCTNmD3KxGtg5nlzUBJc=" crossorigin=anonymous async></script></body></html>